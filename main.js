"use strict";
/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => AutoCardEmbedPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian6 = require("obsidian");

// src/settings.ts
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  showPopupOnPaste: true,
  showInMenuItem: true,
  enableYouTubeEmbed: true,
  enableTwitterEmbed: true
};
var AutoCardEmbedSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Paste popup").setDesc(
      "URL\u3092\u8CBC\u308A\u4ED8\u3051\u305F\u3068\u304D\u306B\u30DD\u30C3\u30D7\u30A2\u30C3\u30D7\u3067\u8868\u793A\u65B9\u6CD5\u3092\u9078\u629E\u3059\u308B"
    ).addToggle((val) => {
      if (!this.plugin.settings)
        return;
      return val.setValue(this.plugin.settings.showPopupOnPaste).onChange(async (value) => {
        if (!this.plugin.settings)
          return;
        this.plugin.settings.showPopupOnPaste = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Context menu").setDesc("\u53F3\u30AF\u30EA\u30C3\u30AF\u30E1\u30CB\u30E5\u30FC\u306B\u30B3\u30DE\u30F3\u30C9\u3092\u8FFD\u52A0\u3059\u308B").addToggle((val) => {
      if (!this.plugin.settings)
        return;
      return val.setValue(this.plugin.settings.showInMenuItem).onChange(async (value) => {
        if (!this.plugin.settings)
          return;
        this.plugin.settings.showInMenuItem = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("YouTube embed").setDesc(
      "YouTube URL\u306E\u57CB\u3081\u8FBC\u307F\u8868\u793A\u3092\u6709\u52B9\u306B\u3059\u308B"
    ).addToggle((val) => {
      if (!this.plugin.settings)
        return;
      return val.setValue(this.plugin.settings.enableYouTubeEmbed).onChange(async (value) => {
        if (!this.plugin.settings)
          return;
        this.plugin.settings.enableYouTubeEmbed = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Twitter/X embed").setDesc(
      "Twitter/X URL\u306E\u57CB\u3081\u8FBC\u307F\u8868\u793A\u3092\u6709\u52B9\u306B\u3059\u308B"
    ).addToggle((val) => {
      if (!this.plugin.settings)
        return;
      return val.setValue(this.plugin.settings.enableTwitterEmbed).onChange(async (value) => {
        if (!this.plugin.settings)
          return;
        this.plugin.settings.enableTwitterEmbed = value;
        await this.plugin.saveSettings();
      });
    });
  }
};

// src/utils/regex.ts
var urlRegex = /^(https?:\/\/(?:www\.|(?!www))[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\.[^\s]{2,}|www\.[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\.[^\s]{2,}|https?:\/\/(?:www\.|(?!www))[a-zA-Z0-9]+\.[^\s]{2,}|www\.[a-zA-Z0-9]+\.[^\s]{2,})$/i;
var lineRegex = /(https?:\/\/(?:www\.|(?!www))[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\.[^\s]{2,}|www\.[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\.[^\s]{2,}|https?:\/\/(?:www\.|(?!www))[a-zA-Z0-9]+\.[^\s]{2,}|www\.[a-zA-Z0-9]+\.[^\s]{2,})/gi;
var linkRegex = /^\[([^[\]]*)\]\((https?:\/\/(?:www\.|(?!www))[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\.[^\s]{2,}|www\.[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\.[^\s]{2,}|https?:\/\/(?:www\.|(?!www))[a-zA-Z0-9]+\.[^\s]{2,}|www\.[a-zA-Z0-9]+\.[^\s]{2,})\)$/i;
var linkLineRegex = /\[([^[\]]*)\]\((https?:\/\/(?:www\.|(?!www))[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\.[^\s]{2,}|www\.[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\.[^\s]{2,}|https?:\/\/(?:www\.|(?!www))[a-zA-Z0-9]+\.[^\s]{2,}|www\.[a-zA-Z0-9]+\.[^\s]{2,})\)/gi;
var imageRegex = /\.(gif|jpe?g|tiff?|png|webp|bmp|tga|psd|ai)$/i;

// src/editor-enhancements.ts
var EditorExtensions = class {
  static getSelectedText(editor) {
    if (!editor.somethingSelected()) {
      const wordBoundaries = this.getWordBoundaries(editor);
      editor.setSelection(wordBoundaries.start, wordBoundaries.end);
    }
    return editor.getSelection();
  }
  static isCursorWithinBoundaries(cursor, match) {
    var _a;
    const startIndex = (_a = match.index) != null ? _a : 0;
    const endIndex = startIndex + match[0].length;
    return startIndex <= cursor.ch && cursor.ch <= endIndex;
  }
  static getWordBoundaries(editor) {
    var _a, _b;
    const cursor = editor.getCursor();
    const lineText = editor.getLine(cursor.line);
    const linksInLine = lineText.matchAll(linkLineRegex);
    for (const match of linksInLine) {
      if (this.isCursorWithinBoundaries(cursor, match)) {
        const startCh = (_a = match.index) != null ? _a : 0;
        return {
          start: {
            line: cursor.line,
            ch: startCh
          },
          end: { line: cursor.line, ch: startCh + match[0].length }
        };
      }
    }
    const urlsInLine = lineText.matchAll(lineRegex);
    for (const match of urlsInLine) {
      if (this.isCursorWithinBoundaries(cursor, match)) {
        const startCh = (_b = match.index) != null ? _b : 0;
        return {
          start: { line: cursor.line, ch: startCh },
          end: { line: cursor.line, ch: startCh + match[0].length }
        };
      }
    }
    return {
      start: cursor,
      end: cursor
    };
  }
  static getEditorPositionFromIndex(content, index) {
    const substr = content.substr(0, index);
    let l = 0;
    let offset = -1;
    let r = -1;
    for (; (r = substr.indexOf("\n", r + 1)) !== -1; l++, offset = r)
      ;
    offset += 1;
    const ch = content.substr(offset, index - offset).length;
    return { line: l, ch };
  }
};

// src/utils/checkif.ts
var CheckIf = class {
  static isUrl(text) {
    const regex = new RegExp(urlRegex);
    return regex.test(text);
  }
  static isImage(text) {
    const regex = new RegExp(imageRegex);
    return regex.test(text);
  }
  static isLinkedUrl(text) {
    const regex = new RegExp(linkRegex);
    return regex.test(text);
  }
};

// src/card/card-generator.ts
var import_obsidian2 = require("obsidian");

// src/card/metadata-parser.ts
var LinkMetadataParser = class {
  constructor(url, htmlText) {
    this.url = url;
    const parser = new DOMParser();
    const htmlDoc = parser.parseFromString(htmlText, "text/html");
    this.htmlDoc = htmlDoc;
  }
  async parse() {
    var _a, _b;
    const title = (_a = this.getTitle()) == null ? void 0 : _a.replace(/\r\n|\n|\r/g, "").replace(/\\/g, "\\\\").replace(/"/g, '\\"').trim();
    if (!title)
      return;
    const description = (_b = this.getDescription()) == null ? void 0 : _b.replace(/\r\n|\n|\r/g, "").replace(/\\/g, "\\\\").replace(/"/g, '\\"').trim();
    const { hostname } = new URL(this.url);
    const favicon = await this.getFavicon();
    const image = await this.getImage();
    return {
      url: this.url,
      title,
      description,
      host: hostname,
      favicon,
      image,
      indent: 0
    };
  }
  getTitle() {
    var _a, _b;
    const ogTitle = (_a = this.htmlDoc.querySelector("meta[property='og:title']")) == null ? void 0 : _a.getAttr("content");
    if (ogTitle)
      return ogTitle;
    const title = (_b = this.htmlDoc.querySelector("title")) == null ? void 0 : _b.textContent;
    if (title)
      return title;
  }
  getDescription() {
    var _a, _b;
    const ogDescription = (_a = this.htmlDoc.querySelector("meta[property='og:description']")) == null ? void 0 : _a.getAttr("content");
    if (ogDescription)
      return ogDescription;
    const metaDescription = (_b = this.htmlDoc.querySelector("meta[name='description']")) == null ? void 0 : _b.getAttr("content");
    if (metaDescription)
      return metaDescription;
  }
  async getFavicon() {
    var _a;
    const favicon = (_a = this.htmlDoc.querySelector("link[rel='icon']")) == null ? void 0 : _a.getAttr("href");
    if (favicon)
      return await this.fixImageUrl(favicon);
  }
  async getImage() {
    var _a;
    const ogImage = (_a = this.htmlDoc.querySelector("meta[property='og:image']")) == null ? void 0 : _a.getAttr("content");
    if (ogImage)
      return await this.fixImageUrl(ogImage);
  }
  async fixImageUrl(url) {
    if (url === void 0)
      return "";
    const { hostname } = new URL(this.url);
    let image = url;
    if (url && url.startsWith("//")) {
      const testUrlHttps = `https:${url}`;
      const testUrlHttp = `http:${url}`;
      if (await checkUrlAccessibility(testUrlHttps)) {
        image = testUrlHttps;
      } else if (await checkUrlAccessibility(testUrlHttp)) {
        image = testUrlHttp;
      }
    } else if (url && url.startsWith("/") && hostname) {
      const testUrlHttps = `https://${hostname}${url}`;
      const testUrlHttp = `http://${hostname}${url}`;
      const resUrlHttps = await checkUrlAccessibility(testUrlHttps);
      const resUrlHttp = await checkUrlAccessibility(testUrlHttp);
      if (resUrlHttps) {
        image = testUrlHttps;
      } else if (resUrlHttp) {
        image = testUrlHttp;
      }
    }
    async function checkUrlAccessibility(url2) {
      return new Promise((resolve) => {
        const img = new Image();
        img.onload = () => resolve(true);
        img.onerror = () => resolve(false);
        img.src = url2;
      });
    }
    return image;
  }
};

// src/card/card-generator.ts
var CodeBlockGenerator = class {
  constructor(editor) {
    this.editor = editor;
  }
  async convertUrlToCodeBlock(url) {
    const selectedText = this.editor.getSelection();
    const pasteId = this.createBlockHash();
    const fetchingText = `[Fetching Data#${pasteId}](${url})`;
    this.editor.replaceSelection(fetchingText);
    const linkMetadata = await this.fetchLinkMetadata(url);
    const text = this.editor.getValue();
    const start = text.indexOf(fetchingText);
    if (start < 0) {
      console.log(
        `Unable to find text "${fetchingText}" in current editor, bailing out; link ${url}`
      );
      return;
    }
    const end = start + fetchingText.length;
    const startPos = EditorExtensions.getEditorPositionFromIndex(text, start);
    const endPos = EditorExtensions.getEditorPositionFromIndex(text, end);
    if (!linkMetadata) {
      new import_obsidian2.Notice("Couldn't fetch link metadata");
      this.editor.replaceRange(selectedText || url, startPos, endPos);
      return;
    }
    this.editor.replaceRange(this.genCodeBlock(linkMetadata), startPos, endPos);
  }
  genCodeBlock(linkMetadata) {
    const codeBlockTexts = ["\n```cardlink"];
    codeBlockTexts.push(`url: ${linkMetadata.url}`);
    codeBlockTexts.push(`title: "${linkMetadata.title}"`);
    if (linkMetadata.description)
      codeBlockTexts.push(`description: "${linkMetadata.description}"`);
    if (linkMetadata.host)
      codeBlockTexts.push(`host: ${linkMetadata.host}`);
    if (linkMetadata.favicon)
      codeBlockTexts.push(`favicon: ${linkMetadata.favicon}`);
    if (linkMetadata.image)
      codeBlockTexts.push(`image: ${linkMetadata.image}`);
    codeBlockTexts.push("```\n");
    return codeBlockTexts.join("\n");
  }
  async fetchLinkMetadata(url) {
    const res = await (async () => {
      try {
        return (0, import_obsidian2.requestUrl)({ url });
      } catch (e) {
        console.log(e);
        return;
      }
    })();
    if (!res || res.status != 200) {
      console.log(`bad response. response status code was ${res == null ? void 0 : res.status}`);
      return;
    }
    const parser = new LinkMetadataParser(url, res.text);
    return parser.parse();
  }
  createBlockHash() {
    let result = "";
    const characters = "abcdefghijklmnopqrstuvwxyz0123456789";
    const charactersLength = characters.length;
    for (let i = 0; i < 4; i++) {
      result += characters.charAt(Math.floor(Math.random() * charactersLength));
    }
    return result;
  }
};

// src/card/card-processor.ts
var import_obsidian3 = require("obsidian");

// src/interfaces.ts
var YamlParseError = class extends Error {
};
var NoRequiredParamsError = class extends Error {
};

// src/card/card-processor.ts
var CodeBlockProcessor = class {
  constructor(app) {
    this.app = app;
  }
  async run(source, el) {
    try {
      const data = this.parseLinkMetadataFromYaml(source);
      el.appendChild(this.genLinkEl(data));
    } catch (error) {
      if (error instanceof NoRequiredParamsError) {
        el.appendChild(this.genErrorEl(error.message));
      } else if (error instanceof YamlParseError) {
        el.appendChild(this.genErrorEl(error.message));
      } else if (error instanceof TypeError) {
        el.appendChild(
          this.genErrorEl("internal links must be surrounded by quotes.")
        );
        console.log(error);
      } else {
        console.log("Code Block: cardlink unknown error", error);
      }
    }
  }
  parseLinkMetadataFromYaml(source) {
    let yaml;
    let indent = -1;
    source = source.split(/\r?\n|\r|\n/g).map(
      (line) => line.replace(/^\t+/g, (tabs) => {
        const n = tabs.length;
        if (indent < 0) {
          indent = n;
        }
        return " ".repeat(n);
      })
    ).join("\n");
    try {
      yaml = (0, import_obsidian3.parseYaml)(source);
    } catch (error) {
      console.log(error);
      throw new YamlParseError(
        "failed to parse yaml. Check debug console for more detail."
      );
    }
    if (!yaml || !yaml.url || !yaml.title) {
      throw new NoRequiredParamsError(
        "required params[url, title] are not found."
      );
    }
    return {
      url: yaml.url,
      title: yaml.title,
      description: yaml.description,
      host: yaml.host,
      favicon: yaml.favicon,
      image: yaml.image,
      indent
    };
  }
  genErrorEl(errorMsg) {
    const containerEl = document.createElement("div");
    containerEl.addClass("auto-card-link-error-container");
    const spanEl = document.createElement("span");
    spanEl.textContent = `cardlink error: ${errorMsg}`;
    containerEl.appendChild(spanEl);
    return containerEl;
  }
  genLinkEl(data) {
    const containerEl = document.createElement("div");
    containerEl.addClass("auto-card-link-container");
    containerEl.setAttr("data-auto-card-link-depth", data.indent);
    const cardEl = document.createElement("a");
    cardEl.addClass("auto-card-link-card");
    cardEl.setAttr("href", data.url);
    containerEl.appendChild(cardEl);
    const mainEl = document.createElement("div");
    mainEl.addClass("auto-card-link-main");
    cardEl.appendChild(mainEl);
    const titleEl = document.createElement("div");
    titleEl.addClass("auto-card-link-title");
    titleEl.textContent = data.title;
    mainEl.appendChild(titleEl);
    if (data.description) {
      const descriptionEl = document.createElement("div");
      descriptionEl.addClass("auto-card-link-description");
      descriptionEl.textContent = data.description;
      mainEl.appendChild(descriptionEl);
    }
    const hostEl = document.createElement("div");
    hostEl.addClass("auto-card-link-host");
    mainEl.appendChild(hostEl);
    if (data.favicon) {
      if (!CheckIf.isUrl(data.favicon))
        data.favicon = this.getLocalImagePath(data.favicon);
      const faviconEl = document.createElement("img");
      faviconEl.addClass("auto-card-link-favicon");
      faviconEl.setAttr("src", data.favicon);
      hostEl.appendChild(faviconEl);
    }
    if (data.host) {
      const hostNameEl = document.createElement("span");
      hostNameEl.textContent = data.host;
      hostEl.appendChild(hostNameEl);
    }
    if (data.image) {
      if (!CheckIf.isUrl(data.image))
        data.image = this.getLocalImagePath(data.image);
      const thumbnailEl = document.createElement("img");
      thumbnailEl.addClass("auto-card-link-thumbnail");
      thumbnailEl.setAttr("src", data.image);
      thumbnailEl.setAttr("draggable", "false");
      cardEl.appendChild(thumbnailEl);
    }
    new import_obsidian3.ButtonComponent(containerEl).setClass("auto-card-link-copy-url").setClass("clickable-icon").setIcon("copy").setTooltip(`Copy URL
${data.url}`).onClick(() => {
      navigator.clipboard.writeText(data.url);
      new import_obsidian3.Notice("URL copied to your clipboard");
    });
    return containerEl;
  }
  getLocalImagePath(link) {
    var _a;
    link = link.slice(2, -2);
    const imageRelativePath = (_a = this.app.metadataCache.getFirstLinkpathDest(
      (0, import_obsidian3.getLinkpath)(link),
      ""
    )) == null ? void 0 : _a.path;
    if (!imageRelativePath)
      return link;
    return this.app.vault.adapter.getResourcePath(imageRelativePath);
  }
};

// src/embed/embed-processor.ts
var import_obsidian4 = require("obsidian");

// src/embed/youtube-embed.ts
var youtubeRegex = /(?:https?:\/\/)?(?:www\.)?youtu(?:\.be\/|be.com\/\S*\b(watch|embed|shorts|v|e|live)\b(?:(?:(?=\/[-a-zA-Z0-9_]{11,}(?!\S))\/)|(?:\S*v=|v\/)))([-a-zA-Z0-9_]{11,})(?:(?:\?|&)t=(\d+)s?)?/;
function createYouTubeEmbed(url) {
  const regexMatch = url.match(youtubeRegex);
  if (regexMatch === null)
    return null;
  const videoType = regexMatch[1];
  const videoId = regexMatch[2];
  if (videoId === void 0)
    return null;
  let embedUrl = "https://www.youtube.com/embed/" + videoId;
  if (regexMatch.length >= 4 && regexMatch[3]) {
    embedUrl += "?start=" + regexMatch[3];
  }
  const iframe = document.createElement("iframe");
  iframe.src = embedUrl;
  iframe.classList.add(
    "auto-card-embed-iframe",
    "youtube" + (videoType === "shorts" ? "-shorts" : "") + "-embed"
  );
  iframe.setAttribute("allowfullscreen", "true");
  iframe.setAttribute("loading", "lazy");
  return iframe;
}

// src/embed/twitter-embed.ts
var twitterRegex = /https:\/\/(?:x|twitter)\.com\/(\w+)(?:\/status\/(\w+))?/;
var sizeCache = {};
function createTwitterEmbed(url, darkMode) {
  const regexMatch = url.match(twitterRegex);
  if (regexMatch === null)
    return null;
  const iframe = document.createElement("iframe");
  const postId = regexMatch[2];
  const isPost = postId !== void 0;
  if (isPost) {
    iframe.src = `https://platform.twitter.com/embed/Tweet.html?dnt=true&theme=${darkMode ? "dark" : "light"}&id=${postId}`;
  } else {
    iframe.src = `https://syndication.twitter.com/srv/timeline-profile/screen-name/${regexMatch[1]}?dnt=true`;
  }
  iframe.classList.add("auto-card-embed-iframe", "twitter-embed-iframe");
  iframe.sandbox.add("allow-forms", "allow-presentation", "allow-same-origin", "allow-scripts", "allow-modals", "allow-popups");
  if (isPost) {
    iframe.setAttribute("scrolling", "no");
  }
  iframe.setAttribute("loading", "lazy");
  if (postId && sizeCache[postId]) {
    iframe.style.height = sizeCache[postId] + "px";
  }
  iframe.dataset.twitterPostId = postId;
  return iframe;
}
function onTwitterResizeMessage(e) {
  if (!e.data || !e.data["twttr.embed"])
    return;
  if (e.data["twttr.embed"]["method"] !== "twttr.private.resize")
    return;
  const params = e.data["twttr.embed"]["params"][0];
  const postId = params["data"]["tweet_id"];
  const iframes = document.querySelectorAll(`.auto-card-embed-twitter-container iframe[data-twitter-post-id="${postId}"]`);
  if (iframes.length === 0)
    return;
  for (let i = 0; i < iframes.length; ++i) {
    const iframe = iframes[i];
    const height = params["height"] + 1;
    iframe.style.height = height + "px";
    if (iframe.parentElement) {
      iframe.parentElement.style.height = height + "px";
    }
    if (postId) {
      sizeCache[postId] = height;
    }
  }
}

// src/embed/embed-processor.ts
var EmbedProcessor = class {
  constructor(darkMode) {
    this.darkMode = darkMode;
  }
  run(source, el) {
    let data;
    try {
      const normalizedSource = source.split(/\r?\n|\r|\n/g).map((line) => line.replace(/^\t+/g, (tabs) => " ".repeat(tabs.length))).join("\n");
      data = (0, import_obsidian4.parseYaml)(normalizedSource);
    } catch (error) {
      console.log("autoembed: YAML parse error", error);
      el.appendChild(this.genErrorEl("YAML\u306E\u89E3\u6790\u306B\u5931\u6557\u3057\u307E\u3057\u305F"));
      return;
    }
    if (!data || !data.url || !data.type) {
      el.appendChild(this.genErrorEl("url \u3068 type \u304C\u5FC5\u8981\u3067\u3059"));
      return;
    }
    let embed = null;
    if (data.type === "youtube") {
      embed = createYouTubeEmbed(data.url);
    } else if (data.type === "twitter") {
      embed = createTwitterEmbed(data.url, this.darkMode);
    }
    if (!embed) {
      el.appendChild(this.genErrorEl(`\u57CB\u3081\u8FBC\u307F\u306E\u751F\u6210\u306B\u5931\u6557\u3057\u307E\u3057\u305F: ${data.url}`));
      return;
    }
    const containerEl = document.createElement("div");
    if (data.type === "twitter") {
      containerEl.classList.add("auto-card-embed-twitter-container");
    } else {
      containerEl.classList.add("auto-card-embed-container");
    }
    containerEl.appendChild(embed);
    el.appendChild(containerEl);
  }
  genErrorEl(errorMsg) {
    const containerEl = document.createElement("div");
    containerEl.classList.add("auto-card-embed-error");
    const spanEl = document.createElement("span");
    spanEl.textContent = `autoembed error: ${errorMsg}`;
    containerEl.appendChild(spanEl);
    return containerEl;
  }
};

// src/paste-suggest.ts
var import_obsidian5 = require("obsidian");

// src/url-detector.ts
function detectUrlType(url) {
  if (youtubeRegex.test(url)) {
    return "youtube";
  }
  if (twitterRegex.test(url)) {
    return "twitter";
  }
  return "general";
}

// src/paste-suggest.ts
function showPasteMenu(editor, url, options) {
  var _a, _b;
  const urlType = detectUrlType(url);
  const menu = new import_obsidian5.Menu();
  if (urlType !== "twitter") {
    menu.addItem((item) => {
      item.setTitle("Card").setIcon("credit-card").onClick(() => {
        const generator = new CodeBlockGenerator(editor);
        generator.convertUrlToCodeBlock(url);
      });
    });
  }
  if (urlType === "youtube" && options.enableYouTubeEmbed || urlType === "twitter" && options.enableTwitterEmbed) {
    menu.addItem((item) => {
      item.setTitle("Embed").setIcon("play").onClick(() => {
        insertEmbed(editor, url);
      });
    });
  }
  if (urlType !== "twitter") {
    menu.addItem((item) => {
      item.setTitle("Link with Title").setIcon("link").onClick(async () => {
        await convertUrlToMarkdownLink(editor, url);
      });
    });
  }
  menu.addItem((item) => {
    item.setTitle("Plain URL").setIcon("type").onClick(() => {
      editor.replaceSelection(url);
    });
  });
  const cursor = editor.getCursor();
  const coords = (_b = (_a = editor.cm) == null ? void 0 : _a.coordsAtPos) == null ? void 0 : _b.call(
    _a,
    editor.posToOffset(cursor)
  );
  if (coords) {
    menu.showAtPosition({ x: coords.left, y: coords.bottom + 5 });
  } else {
    menu.showAtMouseEvent(new MouseEvent("click"));
  }
}
function insertEmbed(editor, url) {
  editor.replaceSelection(`![](${url})`);
}
async function convertUrlToMarkdownLink(editor, url) {
  const fetchingText = `[Fetching Title...](${url})`;
  editor.replaceSelection(fetchingText);
  let title;
  try {
    const res = await (0, import_obsidian5.requestUrl)({ url });
    if (res && res.status === 200) {
      const parser = new LinkMetadataParser(url, res.text);
      const metadata = await parser.parse();
      title = metadata == null ? void 0 : metadata.title;
    }
  } catch (e) {
    console.log("auto-card-embed: failed to fetch title", e);
  }
  const text = editor.getValue();
  const start = text.indexOf(fetchingText);
  if (start < 0)
    return;
  const end = start + fetchingText.length;
  const startPos = indexToPos(text, start);
  const endPos = indexToPos(text, end);
  if (title) {
    editor.replaceRange(`[${title}](${url})`, startPos, endPos);
  } else {
    new import_obsidian5.Notice("\u30BF\u30A4\u30C8\u30EB\u3092\u53D6\u5F97\u3067\u304D\u307E\u305B\u3093\u3067\u3057\u305F");
    editor.replaceRange(`[${url}](${url})`, startPos, endPos);
  }
}
function indexToPos(content, index) {
  const substr = content.substr(0, index);
  let l = 0;
  let offset = -1;
  let r = -1;
  for (; (r = substr.indexOf("\n", r + 1)) !== -1; l++, offset = r)
    ;
  offset += 1;
  const ch = content.substr(offset, index - offset).length;
  return { line: l, ch };
}

// src/main.ts
var AutoCardEmbedPlugin = class extends import_obsidian6.Plugin {
  constructor() {
    super(...arguments);
    this.twitterResizeHandler = (e) => {
      if (e.origin === "https://platform.twitter.com") {
        onTwitterResizeMessage(e);
      }
    };
    this.onPaste = async (evt, editor) => {
      var _a, _b, _c, _d, _e;
      if (!((_a = this.settings) == null ? void 0 : _a.showPopupOnPaste))
        return;
      if (!navigator.onLine)
        return;
      if (evt.clipboardData == null)
        return;
      if (evt.clipboardData.files.length > 0)
        return;
      const clipboardText = evt.clipboardData.getData("text/plain");
      if (clipboardText == null || clipboardText == "")
        return;
      if (!CheckIf.isUrl(clipboardText) || CheckIf.isImage(clipboardText)) {
        return;
      }
      evt.stopPropagation();
      evt.preventDefault();
      showPasteMenu(editor, clipboardText, {
        enableYouTubeEmbed: (_c = (_b = this.settings) == null ? void 0 : _b.enableYouTubeEmbed) != null ? _c : true,
        enableTwitterEmbed: (_e = (_d = this.settings) == null ? void 0 : _d.enableTwitterEmbed) != null ? _e : true
      });
    };
    this.onEditorMenu = (menu) => {
      var _a;
      if (!((_a = this.settings) == null ? void 0 : _a.showInMenuItem))
        return;
      menu.addItem((item) => {
        item.setTitle("Paste URL as card").setIcon("paste").onClick(async () => {
          const editor = this.getEditor();
          if (!editor)
            return;
          this.manualPasteAsCard(editor);
        });
      });
      if (!navigator.onLine)
        return;
      menu.addItem((item) => {
        item.setTitle("Enhance selected URL to card").setIcon("link").onClick(() => {
          const editor = this.getEditor();
          if (!editor)
            return;
          this.enhanceSelectedURL(editor);
        });
      });
    };
  }
  async onload() {
    await this.loadSettings();
    this.registerMarkdownCodeBlockProcessor("cardlink", async (source, el) => {
      const processor = new CodeBlockProcessor(this.app);
      await processor.run(source, el);
    });
    this.registerMarkdownCodeBlockProcessor("autoembed", (source, el) => {
      const darkMode = document.body.classList.contains("theme-dark");
      const processor = new EmbedProcessor(darkMode);
      processor.run(source, el);
    });
    window.addEventListener("message", this.twitterResizeHandler);
    this.addCommand({
      id: "auto-card-embed-paste-as-card",
      name: "Paste URL as card",
      editorCallback: async (editor) => {
        await this.manualPasteAsCard(editor);
      },
      hotkeys: []
    });
    this.addCommand({
      id: "auto-card-embed-enhance-selected-url",
      name: "Enhance selected URL to card",
      editorCheckCallback: (checking, editor) => {
        if (!navigator.onLine)
          return false;
        if (checking)
          return true;
        this.enhanceSelectedURL(editor);
      },
      hotkeys: [
        {
          modifiers: ["Mod", "Shift"],
          key: "e"
        }
      ]
    });
    this.registerEvent(this.app.workspace.on("editor-paste", this.onPaste));
    this.registerEvent(this.app.workspace.on("editor-menu", this.onEditorMenu));
    this.addSettingTab(new AutoCardEmbedSettingTab(this.app, this));
  }
  enhanceSelectedURL(editor) {
    const selectedText = (EditorExtensions.getSelectedText(editor) || "").trim();
    const codeBlockGenerator = new CodeBlockGenerator(editor);
    for (const line of selectedText.split(/[\n ]/)) {
      if (CheckIf.isUrl(line)) {
        codeBlockGenerator.convertUrlToCodeBlock(line);
      } else if (CheckIf.isLinkedUrl(line)) {
        const url = this.getUrlFromLink(line);
        codeBlockGenerator.convertUrlToCodeBlock(url);
      }
    }
  }
  async manualPasteAsCard(editor) {
    const clipboardText = await navigator.clipboard.readText();
    if (clipboardText == null || clipboardText == "")
      return;
    if (!navigator.onLine) {
      editor.replaceSelection(clipboardText);
      return;
    }
    if (!CheckIf.isUrl(clipboardText) || CheckIf.isImage(clipboardText)) {
      editor.replaceSelection(clipboardText);
      return;
    }
    const codeBlockGenerator = new CodeBlockGenerator(editor);
    await codeBlockGenerator.convertUrlToCodeBlock(clipboardText);
  }
  getEditor() {
    const view = this.app.workspace.getActiveViewOfType(import_obsidian6.MarkdownView);
    if (!view)
      return;
    return view.editor;
  }
  getUrlFromLink(link) {
    const urlRegex2 = new RegExp(linkRegex);
    const regExpExecArray = urlRegex2.exec(link);
    if (regExpExecArray === null || regExpExecArray.length < 2) {
      return "";
    }
    return regExpExecArray[2];
  }
  onunload() {
    window.removeEventListener("message", this.twitterResizeHandler);
    console.log("unloading auto-card-embed");
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
